```java
public class HelloWorld{
    public static void main(String[] args){
        System.out.println("Hello World");
    }
}
```

# 面向对象基础

## class和class有关的名词

### 访问修饰符

`public`就是公用的声明，叫做访问修饰符吧，这个就是公用的rbq，可以在JVM里被任意地调用出来,访问修饰符有点 **就近原则**的感觉，就算你在公类 `private` 一个 `field`,那个 `field`肯定就不能被调用了

但问题就来了，如果不能在外面被操纵，那 `private`的意义何在？所以方法由此诞生，方法使得对象中的 `field`可以被更安全地只被该类定义的“行为模式”给修改，这便是方法

### 方法

> 一个类通过定义方法，就可以给外部代码暴露一些操作的接口，同时，内部自己保证逻辑一致性。

`main`就是一个典型的方法，**方法**的意思就是**类里面的函数**，这里的 `main`其实还是有点类似于C的作用，是一个.class文件被JVM运行的入口，JVM在运行整个java项目的时候首先就会先去找它，然后再逐行执行，也就是说：

- 除了入口方法 main，其他方法的名字都可以随意。而且这个main其实可以随便放在任意一个平行类里，**而且也不只可以放一个**，如果你放了不只一个class的话，那么编译过程中就会产生多个 `.class`文件，在JVM你可以选择任意一个进行实际的运行

#### this变量

一个始终指向当前实例的隐藏变量，可以访问对象的所有 `field`

#### 可变参数

第一个 **语法糖** *一种让代码更简洁的重构方式*

```java
public void setNames(String... names)
public void setNames(String[] names)
```

- 这两个语句都代表方法所需要的传参为一个数组，但是对与第二条语句，也就是所谓的 `可变参数`，如果你传参写了 **一堆Str的单元素变量，比如 `"Alice", "Bob"`**，那他也会自动打包
- 另外，传统数组参数可接受NULL，但是可变参数并不会允许这样，当 **没有传参**时，会构建一个0元素的变量

#### 构造方法

- 一个连返回值都不配拥有的方法
- 甚至名字都是和类名完全相同，寄生虫啊我看
- 作用就是在 `new`的时候初始化内部的各种字段，初始化到 `合适`的位置，避免在各种情况没有调用类的某些参数时会错误返回到一个 **不合理** 的情况

```java
class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
  
    public String getName() {
        return this.name;
    }

    public int getAge() {
        return this.age;
    }
}
```

- 而且你没有发现吗，所有对象在new的时候后面跟着的写法 **不正是一个同名的方法吗？？** ，这么重要的信息居然被你忽略了
#### 构造方法可以有多种
不同参数数量和类型，java编译器能够自动匹配对应的构造方法

### new

> malloc的方法初始化版，对象创建的一个必要操作
> new除了会开辟一块新的内存，还可以基于参数去调用构造函数，把对象的属性设置好

- 问：如果直接像定义对象一样去使用类，而不去用 `new`，会发生什么呢

#### 方法的层面的工具：

`absract`: 强制用某个子类去实现，可以只声明不写实现

```java
abstract class Shape {
    abstract void draw();  // 必须由子类实现
}
class Circle extends Shape {
    void draw() { System.out.println("画圆"); }
}
```

### 引用值与引用对象引用名

- **引用名** 就是 **变量** 名，可以说相当于 `c`中指针变量名的意思
- **引用值**就是实际存放的**地址**
- **引用对象** ：实际存在**堆**里的数据

> 缺省就是默认的意思
