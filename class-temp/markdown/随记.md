```java
public class HelloWorld{
    public static void main(String[] args){
        System.out.println("Hello World");
    }
}
```

# 面向对象基础

## class和class有关的名词

### 访问修饰符

`public`就是公用的声明，叫做访问修饰符吧，这个就是公用的rbq，可以在JVM里被任意地调用出来,访问修饰符有点 **就近原则**的感觉，就算你在公类 `private` 一个 `field`（字段）,那个 `field`肯定就不能被调用了

但问题就来了，如果不能在外面被操纵，那 `private`的意义何在？所以方法由此诞生，方法使得对象中的 `field`可以被更安全地只被该类定义的“行为模式”给修改，这便是方法

### new（实例化）

> malloc的方法初始化版，对象创建的一个必要操作
> new除了会开辟一块新的内存，还可以基于参数去调用构造函数，把对象的属性设置好

- 问：如果直接像基本类型一样去使用类，而不去用 `new`，会发生什么呢？
  - 答：只是分配了一个用于引用的32bits或者64bits的空间，指向的为null，调用会出错

### 方法

> 一个类通过定义方法，就可以给外部代码暴露一些操作的接口，同时，内部自己保证逻辑一致性。

`main`就是一个典型的方法，**方法**的意思就是**类里面的函数**，这里的 `main`其实还是有点类似于C的作用，是一个.class文件被JVM运行的入口，JVM在运行整个java项目的时候首先就会先去找它，然后再逐行执行，也就是说：

- 除了入口方法 main，其他方法的名字都可以随意。而且这个main其实可以随便放在任意一个平行类里，**而且也不只可以放一个**，如果你放了不只一个class的话，那么编译过程中就会产生多个 `.class`文件，在JVM你可以选择任意一个进行实际的运行

#### this变量

一个始终指向当前实例的隐藏变量，可以访问对象的所有 `field`

#### 可变参数

第一个 **语法糖** *一种让代码更简洁的重构方式*

```java
public void setNames(String... names)
public void setNames(String[] names)
```

- 这两个语句都代表方法所需要的传参为一个数组，但是对与第二条语句，也就是所谓的 `可变参数`，如果你传参写了 **一堆Str的单元素变量，比如 `"Alice", "Bob"`**，那他也会自动打包
- 另外，传统数组参数可接受NULL，但是可变参数并不会允许这样，当 **没有传参**时，会构建一个0元素的变量

#### 构造方法

- 一个连返回值都不配拥有的方法
- 甚至名字都是和类名完全相同，寄生虫啊我看
- 作用就是在 `new`的时候初始化内部的各种字段，初始化到 `合适`的位置，避免在各种情况没有调用类的某些参数时会错误返回到一个 **不合理** 的情况


#### 方法重载
- 当方法定义的形参不同的时候，传入不同数量的参数可以调用不同的

```java
class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return this.name;
    }

    public int getAge() {
        return this.age;
    }
}
```

- 而且你没有发现吗，所有对象在new的时候后面跟着的写法 **不正是一个同名的方法吗？？** ，这么重要的信息居然被你忽略了
#### 构造方法可以有多种
不同参数数量和类型，java编译器能够自动匹配对应的构造方法
构造方法可以这样，其他方法也当然如此，这就是 **方法重构**
```java
int indexOf(int ch) //根据字符的Unicode码查找；
int indexOf(String str) //根据字符串查找；
int indexOf(int ch, int fromIndex) //根据字符查找，但指定起始位置；
int indexOf(String str, int fromIndex) //根据字符串查找，但指定起始位置。
```
### 继承`extends`
当一个新类有很多成员方法完全与某一个其他类一样，避免复制粘贴，所以使用继承

```java
class Person {
    private String name;
    private int age;

    public String getName() {...}
    public void setName(String name) {...}
    public int getAge() {...}
    public void setAge(int age) {...}
}

class Student extends Person {
    // 不要重复name和age字段/方法,
    // 只需要定义新增score字段/方法:
    private int score;

    public int getScore() { … }
    public void setScore(int score) { … }
}
```
所有没有写`extends`的类，都其实继承了`Obeject`

使用`enxdtend`后，具有以下默认的属性
- 子类无法直接访问`private`字段和`private`方法，如果某个父类需要被继承，那可见性改为`protected`会更好一点，`protected`可以被所有继承树上的类或者对象给引用or修改
- 子类引用父类的字段时，可以用`super.fieldName`
- java规定子类的第一条一定是调用父类的构造方法，如果没写会隐式地加上`super()`,你可以在第一行显示的切换任意的构造重载方法
-

#### 阻止继承
有的时候，我们就是不想让类被一些小比崽子继承怎么办？
在java 15之前，只要不是被`final`修饰的类，都能被合理的继承
但之后，用`sealed(封装的意思)`,就可以用`permit`去规定能继承的子类名称
```java
public sealed class Shape permits Rect, Circle, Triangle {
    ...
}
```
---
#### 向上转型
```java
Person p = new Student();
```
java允许这样的new，因为子类具有所有父类的特性
向上转型实际上是把一个子类型安全地变为更加抽象的父类型，所谓向上的上就是如此
#### 向下转型
虽然父类内存里已经存在子类那部分结构，它不是凭空来的，但是一旦被声明为父类，编译器屏蔽掉了子类的方法，所以其实编译器也不知道这个类有没有对应的子类，如果使用`instanceof`方法返回布尔为真，那么相当于告诉你：放心吧，这个父类确实有这个子类

---
- 继承后，是 **is** 关系，如果你的逻辑两个类是 **has** 关系，那么应该用组合（就是把类当成员），而不是继承


### 多态
#### `Override`
其实就是子类定义了一个 **与父类完全相同的方法** ，方法名相同，方法参数相同，返回值也相同，做题区里最常见的`Override`就是在子类中重写`toString`，其实重写`toString`也不一定要用`@Override`，但是如果你在方法前加上这个声明的话，那么编译器会帮你检查拼写，可见性和方法参数的错误（它人还怪好的咧），那么这一个你早就用烂的机制和这个父标题有什么关系呢？

- 那么你能发现，其实JAVA调用同名方法的时候，其真正执行的方法**取决于运行时期实际类型的方法**，这种模式就叫 **多态**
这样说可能还是很抽象，让我们具体一点
定义三个类都有名为`run`的方法
```java
class Person {
    void run() {
        System.out.println("人慢慢跑");
    }
}

class Student extends Person {
    void run() {
        System.out.println("学生飞快地跑");
    }
}

class Teacher extends Person {
    void run() {
        System.out.println("老师稳稳地跑");
    }
}

Person p1 = new Person();
Person p2 = new Student();
Person p3 = new Teacher();

p1.run();  // 人慢慢跑
p2.run();  // 学生飞快地跑
p3.run();  // 老师稳稳地跑
```

以上结果充分表明：“你是 Person 的一员，就应该有 `run` 方法。”，如果将来要新增一个子类，它也能自动正确计算，这就是可扩展性——多态带来的最大好处。允许添加更多类型的子类实现功能扩展，却**不需要修改基于父类的代码**。

来看一个更有实践意义的例子：

首先我定义了一个报税类

```java
class Income {
    protected double income;
    public double getTax() {
        return income * 0.1; // 税率10%
    }
}
```
对于工资收入，可以减去一个基数，那么我们可以从Income派生出SalaryIncome，并覆写getTax()：
```java
class Salary extends Income {
    @Override
    public double getTax() {
        if (income <= 5000) {
            return 0;
        }
        return (income - 5000) * 0.2;
    }
}

```
如果你享受国务院特殊津贴，那么按照规定，可以全部免税：

```java
class StateCouncilSpecialAllowance extends Income {
    @Override
    public double getTax() {
        return 0;
    }
}
```

接着，你给一个有普通收入、工资收入和享受国务院特殊津贴的小伙算税，那么你的文件就可以这样写：
```java
// Polymorphic
public class Main {
    public static void main(String[] args) {
        Income[] incomes = new Income[] {
            new Income(3000),
            new Salary(7500),
            new StateCouncilSpecialAllowance(15000)
        };
        System.out.println(totalTax(incomes));
    }

    public static double totalTax(Income... incomes) {
        double total = 0;
        for (Income income: incomes) {
            total = total + income.getTax();
        }
        return total;
    }
}

class Income {
    protected double income;

    public Income(double income) {
        this.income = income;
    }

    public double getTax() {
        return income * 0.1; // 税率10%
    }
}

class Salary extends Income {
    public Salary(double income) {
        super(income);
    }

    @Override
    public double getTax() {
        if (income <= 5000) {
            return 0;
        }
        return (income - 5000) * 0.2;
    }
}

class StateCouncilSpecialAllowance extends Income {
    public StateCouncilSpecialAllowance(double income) {
        super(income);
    }

    @Override
    public double getTax() {
        return 0;
    }
}

```
这样总算税的方法只需要和**Income**一个类打交道，而无须知道其它子类的存在，非常方便你去增删其它的工资类

#### 覆写Object（超大类）
因为所有的`class`最终都继承自`Object`，而`Object`定义了几个重要的方法：
- `toString`用于把实例转化字符串
- `equals()`用于判断是否逻辑相当
- `hashCode()`计算实例哈希值

根据所要求重现就行，除了equal都比较好理解
```java
    // 比较是否相等:
    @Override
    public boolean equals(Object o) {
        // 当且仅当o为Person类型:
        if (o instanceof Person) {
            Person p = (Person) o;
            // 并且name字段相同时，返回true:
            return this.name.equals(p.name);
        }
        return false;
    }

    //慢慢去理解
```
#### 调用super
有时候你在重写父类方法的时候，正好需要这个父类方法的返回值,或者干脆去调用它，那么你就可以写：
```java
class Person {
    protected String name;
    public String hello() {
        return "Hello, " + name;
    }
}

class Student extends Person {
    @Override
    public String hello() {
        // 调用父类的hello()方法:
        return super.hello() + "!";
    }
}
```
#### final
##### final可修饰方法
被修饰的方法不允许子类重写
##### final以修饰类
被final修饰的类不允许任何的继承
##### final可以修饰字段
被修饰的字段初始化后就不允许任何的引用更改，这里的初始化包括构造方法


### 抽象
#### 抽象方法
如果一个父类方法完全不需要规定任何内容，就比如记忆命途的忆灵出伤模式，大记忆类完全不知道具体是怎么出伤的，只能由具体子类去描述，瑕蝶长夜月是自爆忆灵出伤，阿格莱雅和记忆主是驻场出伤，那么这个记忆命途的`void damage`方法完全不需要写这个东西，只需要：
```java
abstract class memory {
    int hp;
    int power;
    ...
    public abstract void damage();      //仅仅是为了定义方法签名，目的是让子类去覆写它
}
```
**如果一个类里面有抽象方法，那么它必须也得被描述为抽象类，因为它包含了抽象方法，所以它必定无法被“实”例化，只能用于被继承**如果理解不了，想象一下你能弄出一个“记忆”的角色吗？
#### 面向抽象编程
定义抽象父类后，所有的引用对象标签都为该抽象类（构造方法用子类），就算这个子类并不存在，也可以通过抽象的方法去避免编译错误,比如昔涟其实没新建文件夹，但是她肯定会有忆灵出伤的方式，所以在版本前内容有需要的话也可以直接用
```java
memory x = new xilian();
x.damege(1e9);
...
```
这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。

### 接口
当有一个类**只有**抽象方法，连字段都没有，那么他的抽象可以被修饰成`interface`（接口）
- 接口定义的所有方法默认都是 `public abstract` 所以修饰符可以不用写
  ```java
  interface Person {
    void run();
    String getName();
    }
  ```
  这样就足矣

当一个具体的实例要去实现一个接口的方法时，需要使用`implements`，一种类似于：“这个类我要去实现接口里承诺要做的事了”的承诺
```java
class Student implements Person {
    private String name;

    public Student(String name) {
        this.name = name;
    }

    @Override
    public void run() {
        System.out.println(this.name + " run");
    }

    @Override
    public String getName() {
        return this.name;
    }
}
```

JAVA确实只能单继承一个父类，**但是却能`implements`无数个接口**，这就是接口的必要性
但是要注意，若子类`implements`,那必须严格重写全部该接口类声明的**全部方法**


#### 接口继承
一个接口类可以继承另一个接口类，方法如下，相当于扩展了接口方法，很容易理解不细说了：
```java
interface Hello {
    void hello();
}

interface Person extends Hello {
    void run();
    String getName();
}

```

#### 继承关系
有时候总是在别人的项目部署文章里提到xxx接口什么的
对于一个符合规范的代码项目来说：**实例化对象永远只能是某个具体的子类，但引用时应当只通过接口**

#### `default`方法
> 但是要注意，若子类`implements`,那必须严格重写全部该接口类声明的**全部方法**

由此可知，如果在接口类新增一个方法，那么子类必须全部重写，否则报错，这样会有非常大的痛苦
所以Java8可以给接口的抽象方法新增一个`default`修饰符，如果新增的是`deault`方法，所继承的子类就无须全部修改

`default`方法和抽象类的普通方法是有所不同的。因为`interface`没有字段，`default`方法无法访问字段，而抽象类的普通方法可以访问实例字段。

### 静态（`static`）
#### 静态字段
没有被`static`修饰的字段被称为`实例字段`，而被`static`定义的字段被称为`静态字段`，静态字段**不属于任何实例**，所以无论修改哪个实例的静态字段，它都会被修改
- 也正因为如此，接口类也可以去拥有一个静态字段，结合前面所学，我们也能知道在接口类的字段是也只能是`public static final`（不需要去任何实例化，它在类加载阶段即被初始化，存在于方法区，可随意任何实例中被访问但不可被修改的字段），就算你不写，字段也会被编译器自动加上该修饰符
  
不推荐用“实例.静态字段”去访问静态字段，就算你这样写了实际也会被JVM强转，更推荐使用“类名.静态字段”

静态字段命名规则一般是**全大写**

#### 静态方法
调用实例方法**必须通过一个实例变量**，而调用静态方法则不需要实例变量，通过类名就可以调用。**静态方法类似其它编程语言的函数**，这也是为什么main方法总是需要一个`static`修饰的原因，只有这样JVM才能在最开始 **没有创建任何对象，也不知道构造方法、成员字段等信息** 的情况下去生成一个命令行参数数组（也就是`String[] args`）,传递给main方法

工具类常用静态方法，所以写起来不用new来new去的
- Arrays.sort()
- Math.random()



### 引用值与引用对象引用名

- **引用名** 就是 **变量** 名，可以说相当于 `c`中指针变量名的意思
- **引用值**就是实际存放的**地址**
- **引用对象** ：实际存在**堆**里的数据

> 缺省就是默认的意思
